name: Project Automation

on:
  issues:
    types: [opened, edited, closed, reopened, assigned, unassigned, labeled, unlabeled]
  pull_request:
    types: [opened, edited, closed, reopened, assigned, unassigned, labeled, unlabeled, review_requested, review_request_removed, ready_for_review, synchronize]
  workflow_dispatch:
  schedule:
    # Daily maintenance at 6 AM UTC
    - cron: '0 6 * * *'

jobs:
  update-project-board:
    runs-on: ubuntu-latest
    if: github.event_name != 'schedule'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup GitHub CLI
      uses: cli/setup-gh@v2
    
    - name: Update project board
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PROJECT_NUMBER: ${{ github.event.repository.name == 'docqet' && '3' || '1' }}
      run: |
        # Get project ID
        PROJECT_ID=$(gh api graphql -f query='
          query($org:String!, $number:Int!) {
            organization(login: $org) {
              projectV2(number: $number) { id }
            }
          }' -f org=loopcraftlab -f number=$PROJECT_NUMBER --jq '.data.organization.projectV2.id')
        
        # Get issue/PR ID
        if [[ "${{ github.event.issue.node_id }}" != "" ]]; then
          ITEM_ID="${{ github.event.issue.node_id }}"
        elif [[ "${{ github.event.pull_request.node_id }}" != "" ]]; then
          ITEM_ID="${{ github.event.pull_request.node_id }}"
        else
          echo "No issue or PR found"
          exit 0
        fi
        
        # Add item to project if not already there
        gh api graphql -f query='
          mutation($project:ID!, $item:ID!) {
            addProjectV2Item(input: {projectId: $project, contentId: $item}) {
              item { id }
            }
          }' -f project=$PROJECT_ID -f item=$ITEM_ID || echo "Item already in project or error occurred"

  auto-update-status:
    runs-on: ubuntu-latest
    if: github.event_name != 'schedule'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup GitHub CLI
      uses: cli/setup-gh@v2
    
    - name: Auto-update issue status
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PROJECT_NUMBER: ${{ github.event.repository.name == 'docqet' && '3' || '1' }}
      run: |
        # Get project ID
        PROJECT_ID=$(gh api graphql -f query='
          query($org:String!, $number:Int!) {
            organization(login: $org) {
              projectV2(number: $number) { id }
            }
          }' -f org=loopcraftlab -f number=$PROJECT_NUMBER --jq '.data.organization.projectV2.id')
        
        # Get status field ID
        STATUS_FIELD_ID=$(gh api graphql -f query='
          query($project:ID!) {
            node(id: $project) {
              ... on ProjectV2 {
                fields(first: 20) {
                  nodes {
                    ... on ProjectV2Field {
                      id
                      name
                    }
                    ... on ProjectV2SingleSelectField {
                      id
                      name
                      options {
                        id
                        name
                      }
                    }
                  }
                }
              }
            }
          }' -f project=$PROJECT_ID --jq '.data.node.fields.nodes[] | select(.name == "Status") | .id')
        
        # Determine new status based on event
        NEW_STATUS=""
        if [[ "${{ github.event.action }}" == "assigned" ]]; then
          NEW_STATUS="In Progress"
        elif [[ "${{ github.event.action }}" == "unassigned" ]]; then
          NEW_STATUS="Todo"
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "opened" ]]; then
          NEW_STATUS="Review"
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
          NEW_STATUS="Done"
        elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.action }}" == "closed" && "${{ github.event.pull_request.merged }}" == "false" ]]; then
          NEW_STATUS="In Progress"
        fi
        
        if [[ "$NEW_STATUS" != "" ]]; then
          # Get status option ID
          STATUS_OPTION_ID=$(gh api graphql -f query='
            query($project:ID!) {
              node(id: $project) {
                ... on ProjectV2 {
                  fields(first: 20) {
                    nodes {
                      ... on ProjectV2SingleSelectField {
                        id
                        name
                        options {
                          id
                          name
                        }
                      }
                    }
                  }
                }
              }
            }' -f project=$PROJECT_ID --jq '.data.node.fields.nodes[] | select(.name == "Status") | .options[] | select(.name == "'$NEW_STATUS'") | .id')
          
          # Get item ID
          if [[ "${{ github.event.issue.node_id }}" != "" ]]; then
            ITEM_ID="${{ github.event.issue.node_id }}"
          elif [[ "${{ github.event.pull_request.node_id }}" != "" ]]; then
            ITEM_ID="${{ github.event.pull_request.node_id }}"
          fi
          
          # Update status
          if [[ "$ITEM_ID" != "" && "$STATUS_OPTION_ID" != "" ]]; then
            gh api graphql -f query='
              mutation($project:ID!, $item:ID!, $field:ID!, $value:ID!) {
                updateProjectV2ItemFieldValue(input: {
                  projectId: $project
                  itemId: $item
                  fieldId: $field
                  value: { singleSelectOptionId: $value }
                }) {
                  projectV2Item { id }
                }
              }' -f project=$PROJECT_ID -f item=$ITEM_ID -f field=$STATUS_FIELD_ID -f value=$STATUS_OPTION_ID
          fi
        fi

  auto-assign-labels:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup GitHub CLI
      uses: cli/setup-gh@v2
    
    - name: Auto-assign labels based on content
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        ISSUE_TITLE="${{ github.event.issue.title }}"
        ISSUE_BODY="${{ github.event.issue.body }}"
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        
        # Determine labels based on content
        LABELS=""
        
        # Frontend labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "frontend\|ui\|ux\|react\|next\|typescript\|javascript"; then
          LABELS="$LABELS,frontend"
        fi
        
        # Backend labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "backend\|api\|fastapi\|python\|database\|postgres"; then
          LABELS="$LABELS,backend"
        fi
        
        # AI labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "ai\|ml\|openai\|gpt\|embedding\|vector"; then
          LABELS="$LABELS,ai"
        fi
        
        # Security labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "security\|auth\|authentication\|authorization\|jwt"; then
          LABELS="$LABELS,security"
        fi
        
        # Performance labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "performance\|optimization\|speed\|cache"; then
          LABELS="$LABELS,performance"
        fi
        
        # Documentation labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "documentation\|docs\|readme\|guide"; then
          LABELS="$LABELS,documentation"
        fi
        
        # Testing labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "test\|testing\|pytest\|jest"; then
          LABELS="$LABELS,testing"
        fi
        
        # CI/CD labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "ci\|cd\|pipeline\|deploy\|docker"; then
          LABELS="$LABELS,ci/cd"
        fi
        
        # Priority labels
        if echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "urgent\|critical\|blocker\|p0"; then
          LABELS="$LABELS,priority-high"
        elif echo "$ISSUE_TITLE $ISSUE_BODY" | grep -qi "important\|high\|p1"; then
          LABELS="$LABELS,priority-medium"
        else
          LABELS="$LABELS,priority-low"
        fi
        
        # Add labels if any were determined
        if [[ "$LABELS" != "" ]]; then
          LABELS=$(echo $LABELS | sed 's/^,//')
          gh issue edit $ISSUE_NUMBER --add-label $LABELS
        fi

  weekly-maintenance:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup GitHub CLI
      uses: cli/setup-gh@v2
    
    - name: Weekly project maintenance
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        PROJECT_NUMBER: ${{ github.event.repository.name == 'docqet' && '3' || '1' }}
      run: |
        # Generate weekly report
        echo "## Weekly Project Report - $(date +%Y-%m-%d)" > weekly-report.md
        echo "" >> weekly-report.md
        
        # Get project statistics
        echo "### Project Statistics" >> weekly-report.md
        gh issue list --limit 100 --json number,title,state,labels,assignees,createdAt,updatedAt | jq -r '.[] | "\(.number) | \(.title) | \(.state) | \(.labels[].name // "none")"' >> weekly-report.md
        
        echo "" >> weekly-report.md
        echo "### Recent Activity" >> weekly-report.md
        gh issue list --limit 10 --json number,title,updatedAt | jq -r '.[] | "- #\(.number): \(.title) (updated: \(.updatedAt))"' >> weekly-report.md
        
        # Create weekly summary issue
        gh issue create --title "Weekly Project Summary - $(date +%Y-%m-%d)" \
          --body-file weekly-report.md \
          --label "documentation,automation"
    
    - name: Clean up old issues
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Close stale issues (older than 30 days with no activity)
        STALE_ISSUES=$(gh issue list --limit 100 --json number,updatedAt,state --jq '.[] | select(.state == "open" and (.updatedAt | fromdateiso8601) < (now - 30*24*60*60)) | .number')
        
        for issue in $STALE_ISSUES; do
          gh issue comment $issue --body "This issue has been inactive for 30+ days. Closing as stale. Please reopen if still relevant."
          gh issue close $issue
        done

  dependency-updates:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Check for dependency updates
      run: |
        # Check Python dependencies
        cd backend
        pip install pip-review
        pip-review --local --interactive=false > dependency-updates.txt || echo "No Python updates available"
        
        # Check Node.js dependencies
        cd ../frontend
        npm outdated > npm-outdated.txt || echo "No Node.js updates available"
        
        # Create dependency update issue if needed
        if [ -s ../backend/dependency-updates.txt ] || [ -s npm-outdated.txt ]; then
          echo "## Dependency Updates Available" > dependency-report.md
          echo "" >> dependency-report.md
          echo "### Python Dependencies" >> dependency-report.md
          cat ../backend/dependency-updates.txt >> dependency-report.md
          echo "" >> dependency-report.md
          echo "### Node.js Dependencies" >> dependency-report.md
          cat npm-outdated.txt >> dependency-report.md
          
          gh issue create --title "Dependency Updates Available - $(date +%Y-%m-%d)" \
            --body-file dependency-report.md \
            --label "ci/cd,maintenance"
        fi 